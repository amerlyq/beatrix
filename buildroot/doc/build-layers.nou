SPDX-FileCopyrightText: 2020 Dmytro Kolomoiets <amerlyq@gmail.com> and contributors.

SPDX-License-Identifier: CC-BY-SA-4.0
-----
%%%% Build RO Layering / RW Overlays

  ? What configuration hierarchy do we really need ?
    ::: composition of flat components == use docker only as simple script (with deps)

  [_] FIND: run docker from IDE / CLion
    => otherwise you must configure CMake on host to use docker wrappers
      !! i.e. you can't use cmake from inside docker too ??
      OR:CHECK: only replacing /path/to/cmake cmdline by docker prefix will be enough ?


%% ARCH:(low-level): Integration

  * each pkg -> into buildroot
  * all pkgs -> into buildroot
  * on-top-of buildroot -> reimplement everything above rootfs
  * on-top-of buildroot -> export SDK and reimplement everything
  * split buildroot into two separate buildroots

  !! integrators build everything from zero
    MAYBE: they also can benefit from ccache and prebuilt FOSS packages (and linux kernel) inside sdk prefix
      <= because their main target is integrating together proprietary code
      THINK: or their target is integrating everything including FOSS ?
        => then you must always build everything from zero
        OR:(reversed): you may cache every artifact by hash
    NEED: use vanilla buildroot "as-is" to reuse your general experience
      ! don't create wrappers and don't split/disrupt workflow
      * embed your private projects into ./package/
    goal: get full flashing image == don't touch sources OR touch all sources at once (merge PRs)

  !! developers need dev-sysroot :: pre-built deps only for their components
    BUT: they must be able to clean-up from deps all files removed in newer revision
    ? must provide rootfs-per-package with separately installed packages (once again)
      => then developer can locally clean and rebuild resulting ./target/ from overlays
      !!! isn't it _exactly_ how .pkg for yocto works !!!


%% CFG: Configuration Matrix

  ? ccache
  = dependencies :: none (toolchain), bare (?busybox?), deps (component/s), all
    - none = to build standalone experimental code / package outside of docker e.g. autotools/make/cmake
    - deps = per component docker, generated by jenkins (or team) when testing clean roootfs per component
      ALSO: deps can be generated only locally
    - all  = generated as whole for each new release on jenkins
      CMP: pre-populated rw .vs. overlay ro (both are transparently the same in docker)
  = deliverables :: rootfs, +?sdk?, +staging (isolated devprefix), +stampfiles, +builddir, +repo (!src always rsync to build!)
  = producers :: component-developer, foreign-developer, full-integrator, jenkins
  = devtools :: none (integration), all (development), host (manual)
  = hosts :: transparent (linux), isolated (windows,macos)
    - transparent = docker is no more than "script with deps"
      = you run it as wrapper to GCC and CMake to prevent issues with older/newer host deps
      ++ you can setup your IDE to call all commands through docker prefix cmdline and build/debug directly from IDE
    - isolated = all your tools are inside docker and you work *exclusively* from inside its shell
      = to have not only build but also all required tools available
      ~ or because you can't do anything outside of docker


%% USAGE:(high-level): usecases

  * add-new/remove/split component
  * make isolated changes to single component
    + readonly devprefix
  * make changes to kernel
    MAYBE: create virtual component for linux-kernel
    - minimal BR configuration
      ! NEED: reuse initramfs and external .ko modules which you don't touch
      ! must be dynamic, because testing/tools strongly depend on what exactly you change in kernel
    - add useful development tools deps used only for kernel devs
    - separate deploy routines for drivers/lkms/patches
      = because must rebuild whole kernel to test changes
      ? FIND: is there binary hot-patching for kernel ?
  * make cooperative changes to multiple components (choices/overlay)
    WARN:NEED: clean rootfs -- e.g. if some header files were removed
  * modify underlying buildsystem -- affect all components
  * clean integration (from zero) -- to merge multiple PRs to single component
    + single configuration file to affect all build layers
    ALT: pick prebuilt components to compose single integration rootfs
      <= merging multiple PRs still requires creating totally new ELF from merge revision
      NICE: it can be built only once if each artifact is indexed by repo hash
        OR:BET: if builds are binary identical and reproducible


%% IMPL: read-only layers / overlayfs

  * freeze only stampfiles (to keep rootfs), delete all other default build dirs
    ? but how about rsync of user files ?
  * rootfs overlay mix-ins :: install, deploy
